%{

#include <stdint.h>
#include <sys/types.h>

extern void *tree_alloc(size_t);

#define ALLOC(size)	tree_alloc(size)

%}


quoted			::= SingleQuoted(string escaped_text)
			 | DoubleQuoted(word_stack words)
			 ;

special_param		::= AllPositionalA
			 | AllPosiitionalB
			 | NoOfPos
			 | LastExit
			 | AsyncExit
			 | ProcId
			 | FlagOpts
			 | EnvName
			 ;


parameter		::= PositionalParam(int pos)
			 | SpecialParam(special_param special)
			 | VariableParam(identifier name)
			 ;

glob_wc			::= MatchOne | MatchMany ;


glob			::= Wildcard(glob_wc wildcard)
			 | LiteralChar(uchar lit_char)
			 | Bracket(bool neg, string contents)
			 | GlobStack(glob_stack stack)
			 ;

glob_stack		::= (glob* stack) ;


expand_path		::= Tilde(string suffix)
			 | Glob(glob pattern)
			 ;


expand_param_sub       ::= Defl(parameter param, word? word_opt, bool colon)
			 | Assign(parameter param, word? word_opt, bool colon)
			 | Error(parameter param, word? word_opt, bool colon)
			 | Alt(parameter param, word? word_opt, bool colon)
			 ;


expand_param_rm		::= RemoveSuffix(parameter param, word? word_opt, bool large)
			 | RemovePrefix(parameter param, word? word_opt, bool large)
			 ;

expand_param		::= Simple(parameter to_expn)
			 | Substitute(expand_param_sub sub_param)
			 | Remove(expand_param_rm rm_param)
			 | Strlen(parameter len_param)
			 ;


arith			::= Num(int64 n)
			 | Variable(identifier var)
			 | Nested(arith* list_nested)
			 | Add(arith l, arith r)
			 | Sub(arith l, arith r)
			 | Mul(arith l, arith r)
			 | Div(arith l, arith r)
			 | Mod(arith l, arith r)
			 | Shr(arith l, arith r)
			 | Shl(arith l, arith r)
			 ;


expansion		::= Path(expand_path path_expn)
			 | Param(expand_param param_expn)
			 | Command(command cmd_expn)
			 | Arith(arith arith_expn)
			 ;


word			::= Literal(string word_literal)
			 | Expansion(expansion word_expn)
			 | Quoted(quoted word_quoted)
			 ;


word_stack		::= (word* stack) ;


redirection		::= RedirIn(int? fno, word redir_word)
			 | RedirOut(int? fno, word redir_word)
			 | AppendOut(int? fno, word redir_word)
			 | HereDoc(int? fno, word document, word delim, bool untab)
			 | DupInFd(int? fno, word redir_word)
			 | DupOutFd(int? fno, word redir_word)
			 | OpenRw(int? fno, word redir_word)
			 ;


simple_command		::= NonTermCmd(word_stack words, redirection? redir) 
			 | SeqTermCmd(word_stack words, redirection? redir)
			 | AsynTermCmd(word_stack words, redirection? redir)
			 ;


pipeline		::= NonTermPipe(simple_command* commands)
			 | SeqTermPipe(simple_command* commands)
			 | AsyncTermPipe(simple_command* commands)


compound_list		::= PipelineBase(pipeline pipeln)
			 | And(compound_list* list)
			 | Or(compound_list* list)
			 | Newline(compound_list* list)
			 ;


grouped_compound_cmd	::= SubShell(compound_list body)
			 | SameShel(compound_list body)
			 ;

looped_compound_cmd	::= ForLoop(identifier name, word_stack words, compound_list body)
			 | WhileLoop(compound_list ls1, compound_list ls2)
			 | UntilLoop(compound_list ls1, compound_list ls2)
			 ;


case_condition		::= (glob* patterns, compound_list body) ;

if_condition		::= (compound_list cond, compound_list body) ;


condition_compound_cmd  ::= CaseCond(word_stack words, case_condition* body)
			 | IfCond(if_condition if_base, if_condition* elifs, compound_list? else_base)
			 ;

funcdef_compound_cmd	::= (identifier name, compound_command body, redirection? redir) ;


compound_command	::= Grouped(grouped_compound_cmd grouped)
			 | Looped(looped_compound_cmd looped)
			 | Condition(condition_compound_cmd condition)
			 | Function(funcdef_compound_cmd funcdef)
			 ;


command			::= Word(word_stack words)
			 | List(compound_list list)
			 | SimpleCmd(simple_command simple_cmd)
			 | CompoundCommand(compound_command compound_cmd)
			 ;


command_stack		::= (command* stack) ;


shell_body		::= (command_stack elements, string shebang) ;


